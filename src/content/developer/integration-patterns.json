{
  "patterns": [
    {
      "id": "nextjs-app-router",
      "name": "Next.js App Router Integration",
      "useCase": "Ideal for modern React applications that want full control over auth primitives and session creation.",
      "steps": [
        "Use a Route Handler (`app/api/auth/lnurl/route.ts`) to generate `k1` and construct the LNURL.",
        "Persist `k1` in a short-lived key-value store (KV, Redis, or in-memory).",
        "Return encoded LNURL for QR display.",
        "Implement a callback route (`app/api/auth/callback/route.ts`) that verifies signed responses.",
        "On valid signature, create a session with a cookie or JWT.",
        "Redirect user back to UI with authenticated state."
      ],
      "pros": [
        "Absolute control over the authentication lifecycle.",
        "Fits perfectly with RSC and server actions.",
        "Simple to reason about and maintain."
      ],
      "cons": [
        "Custom session logic may be required.",
        "Crypto libraries may need polyfills in edge runtimes."
      ]
    },
    {
      "id": "nextauth-provider",
      "name": "NextAuth Custom Provider",
      "useCase": "Best choice for apps already standardized on NextAuth and want to unify multiple login options.",
      "steps": [
        "Create a custom LNURL-auth provider that initiates the challenge generation.",
        "Override `authorize()` to handle callback verification.",
        "Map pubkey â†’ user record and return a full NextAuth user object.",
        "Let NextAuth persist cookies and sessions via its built-in adapters."
      ],
      "pros": [
        "Unified login UX.",
        "Sessions, adapters, and JWT flows handled automatically.",
        "Great for teams with existing OAuth infrastructure."
      ],
      "cons": [
        "Provider logic is more abstract and less explicit.",
        "Requires deeper familiarity with NextAuth's internals."
      ]
    },
    {
      "id": "express-middleware",
      "name": "Express / Node Middleware",
      "useCase": "Great for backend services where frontend is decoupled or server-rendered.",
      "steps": [
        "Create `/auth/lnurl` endpoint for challenge generation.",
        "Store `k1` in memory/Redis with expiry.",
        "Serve QR code to client.",
        "Callback endpoint verifies `{ key, sig, k1 }`.",
        "Issue session token or JWT.",
        "Return authenticated response."
      ],
      "pros": [
        "Minimal, explicit, easy to audit.",
        "Good for microservices-based architectures."
      ],
      "cons": [
        "No built-in session system.",
        "Must choose and manage security primitives manually."
      ]
    }
  ]
}

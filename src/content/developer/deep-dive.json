{
  "protocolName": "LNURL-auth",
  "overview": "LNURL-auth is a specialized application of LNURL that enables challenge–response authentication using deterministic per-domain keypairs. It combines the UX affordance of QR-based flows with the cryptographic robustness of Ed25519 or Secp256k1 signatures. The protocol is designed to be simple: no blockchain interaction, no Lightning payment channel required, no invoice settlement. Pure offline signing and verification.",
  "flowDiagramSteps": [
    "1. Client requests a login session from the server (GET /api/auth/lnurl).",
    "2. Server generates a 32-byte random `k1` challenge using cryptographically secure random number generation and stores it temporarily with a 5-minute expiration.",
    "3. Server constructs the callback URL with query parameters (tag=login&k1=...) and encodes it to an LNURL string using bech32 encoding (lnurl1...).",
    "4. Frontend displays the LNURL as a QR code. Wallet scans the QR code and decodes the bech32 LNURL back to the callback URL.",
    "5. Wallet recognizes tag=login as an LNURL-auth request and derives a per-domain deterministic private key using BIP32-like derivation from the wallet seed.",
    "6. Wallet prompts user to approve login, then signs the `k1` challenge with the derived private key using ECDSA (secp256k1).",
    "7. Wallet sends GET request to callback URL with query parameters: `key` (public key), `sig` (signature), and `k1` (challenge).",
    "8. Server verifies the k1 exists, hasn't expired, and hasn't been used. Then verifies the signature: `verifyAuthorizationSignature(sig, k1, pubkey)`.",
    "9. If signature is valid, server creates a session cookie (httpOnly, containing the pubkey) and returns {status: 'OK'}.",
    "10. Frontend detects authentication (via WebSocket or polling) and reloads to show logged-in state."
  ],
  "cryptography": {
    "keys": "LNURL-auth wallets derive per-domain keys using hierarchical deterministic logic (typically BIP32-like derivation). This prevents cross-site correlation while still allowing users to preserve access over time. Each domain gets its own linking key (public key) derived from the user's wallet seed. Some wallets use BIP32 derivation paths; others maintain an internal derivation scheme, but the principle is the same: deterministic, domain-specific key derivation.",
    "signatures": "Signatures use ECDSA (Elliptic Curve Digital Signature Algorithm) with the secp256k1 curve — the same cryptography used in Bitcoin transactions. The signature covers only the `k1` challenge and not arbitrary messages, making verification straightforward. While some wallets may support Ed25519 in the future, the current standard is secp256k1 ECDSA for maximum compatibility with Bitcoin wallets.",
    "challengeResponse": "The challenge (`k1`) is a 32-byte random nonce generated by the server using cryptographically secure random number generation. The wallet signs this nonce as proof of possession of the domain-derived private key. The signature is valid only for this specific login attempt — preventing replay attacks when implemented correctly. The k1 challenge expires after 5 minutes and is single-use (deleted after successful authentication)."
  },
  "serverResponsibilities": [
    "Generate cryptographically secure 32-byte random values (`k1`).",
    "Store `k1` temporarily (5-minute expiry recommended).",
    "Associate `k1` with a pending login attempt or session fingerprint.",
    "Verify signatures using the LNURL-auth crypto spec.",
    "Create new user records when a previously unseen pubkey logs in.",
    "Invalidate `k1` immediately after successful verification."
  ],
  "walletResponsibilities": [
    "Recognize the LNURL-auth request type and parse metadata.",
    "Derive a domain-specific private key.",
    "Prompt user to approve login.",
    "Sign the `k1` challenge.",
    "Send `{ key, sig, k1 }` to callback."
  ],
  "risks": [
    "If `k1` values are not expired or invalidated, replay attacks become possible.",
    "If the same pubkey is reused across non-LNURL-auth contexts, linkability increases.",
    "Server operators must avoid storing or logging private data from wallets.",
    "A compromised wallet compromises all derived identities.",
    "Improper verification libraries can introduce signature validation bypasses."
  ]
}

{
  "id": "lightning-login-developer-v1",
  "title": "Lightning Login for Developers",
  "tagline": "How LNURL-auth works under the hood and how to build it yourself.",
  "navOrder": [
    "overview",
    "vibe-coding",
    "architecture",
    "protocol-flow",
    "implementation-walkthrough",
    "implementing-simple",
    "implementing-nextauth",
    "libraries",
    "comparison",
    "faq"
  ],
  "sections": [
    {
      "id": "overview",
      "slug": "overview",
      "kind": "overview",
      "title": "What Developers Need to Know",
      "paragraphs": [
        "Lightning Login is an authentication protocol using LNURL-auth that allows users to authenticate with websites using their Bitcoin/Lightning wallet instead of passwords or email-based accounts.",
        "This documentation covers the technical implementation details, protocol flow, code examples, and integration patterns for developers who want to add Lightning Login to their applications.",
        "Whether you're building a simple Node.js server or integrating with NextAuth.js, this guide will walk you through the process step by step.",
        "If you're new to Lightning Login concepts, start with the Education section to understand why it matters and how it compares to other authentication methods. Then return here for implementation details."
      ]
    },
    {
      "id": "vibe-coding",
      "slug": "vibe-coding",
      "kind": "step-by-step",
      "title": "Vibe coding: add Lightning Login (LNURL-auth) to your project",
      "intro": "This site is a learning resource and a reference implementation. Use the prompt below to “vibe code” Lightning Login into a new or existing project by mirroring the exact flow used in this demo.",
      "paragraphs": [
        "We call the integration shape “LNURL-with”: LNURL-auth (challenge + signature verification) with the practical glue real apps need — short-lived k1 storage, a secure httpOnly session cookie, and a real-time “did the user authenticate yet?” signal (WebSocket with polling fallback).",
        "If you’re building this in a Next.js App Router app, implement it as Route Handlers under app/api. The server generates the k1 challenge, encodes a callback URL into a bech32 LNURL string, and returns { k1, lnurl } as JSON. The wallet then calls your callback route with k1, key, and sig; the server verifies the signature and sets an httpOnly cookie session.",
        "The reason we add “with” glue: LNURL-auth alone proves key ownership, but it doesn’t solve app ergonomics. You still need k1 lifecycle (expiry + single-use), an authenticated session boundary (cookie), and a reliable way for the UI to learn “the wallet just finished” (WebSocket + polling fallback).",
        "The prompt is intentionally portable across environments (Cursor, ChatGPT, Claude, Copilot Chat). If your environment can read files and apply patches, point it at this repo and tell it to mirror the endpoint behavior here. If it cannot, have it output a patch/diff.",
        "Your end result should look like this demo: an endpoint that returns { k1, lnurl }, a callback that verifies (sig, k1, pubkey) and creates a session, and a UI that shows a QR code then flips to logged-in automatically."
      ],
      "codeExamples": [
        {
          "id": "nextjs-lnurl-with-file-map",
          "title": "Next.js App Router file map (LNURL-with)",
          "description": "A minimal file layout for LNURL-with in a Next.js app (mirrors this demo).",
          "language": "text",
          "code": "app/\n  api/\n    auth/\n      lnurl/route.ts      # GET: generate k1 + return {k1, lnurl}\n      callback/route.ts   # GET: verify signature, set session cookie\n      status/route.ts     # GET: return {authenticated} for a given k1 (polling fallback)\n    ws/\n      auth/route.ts       # WebSocket: push auth success for a given k1\n\nlib/\n  lnurl/\n    generateK1.ts         # crypto.randomBytes(32)->hex\n    encodeLNURL.ts        # lnurl.encode(urlString)\n    verifySignature.ts    # lnurl.verifyAuthorizationSignature(sig,k1,pubkey)\n  store/\n    pendingLogins.ts      # pending k1 store + 5 minute expiry + single-use\n  session/\n    createSession.ts      # sets httpOnly cookie\n    getSession.ts         # reads httpOnly cookie\n\napp/demo/\n  LoginPanel.tsx          # UI: fetch lnurl, render QR, subscribe WS + polling\n"
        },
        {
          "id": "nextjs-lnurl-endpoint-shape",
          "title": "Route Handler: LNURL endpoint (shape)",
          "description": "The LNURL endpoint returns the challenge (k1) and the bech32 LNURL string for QR encoding. Compare to: src/app/api/auth/lnurl/route.ts",
          "language": "typescript",
          "code": "export async function GET() {\n  // 1) Generate cryptographically secure k1 (32 bytes -> 64 hex chars)\n  // 2) Store k1 as pending (expires in 5 minutes)\n  // 3) Build callback URL: /api/auth/callback?tag=login&k1=...\n  // 4) Encode callback URL to bech32 LNURL string\n  // 5) Return { k1, lnurl }\n}\n"
        },
        {
          "id": "nextjs-callback-endpoint-shape",
          "title": "Route Handler: callback (shape)",
          "description": "The callback verifies k1 + signature, then creates a session cookie. Compare to: src/app/api/auth/callback/route.ts",
          "language": "typescript",
          "code": "export async function GET(request: Request) {\n  const { searchParams } = new URL(request.url);\n  const k1 = searchParams.get(\"k1\");\n  const pubkey = searchParams.get(\"key\");\n  const sig = searchParams.get(\"sig\");\n\n  // Validate inputs\n  // Verify k1 exists + is not expired + is pending (single-use)\n  // Verify signature using lnurl.verifyAuthorizationSignature(sig, k1, pubkey)\n  // Create httpOnly session cookie (secure in production, sameSite: 'lax')\n  // Mark k1 complete and invalidate it to prevent replay\n  // Return { status: \"OK\" } (or {status:\"ERROR\", reason:\"...\"})\n}\n"
        },
        {
          "id": "nextjs-status-and-ws-notes",
          "title": "Status + WebSocket: why you need both",
          "description": "WebSockets make the UI feel instant; polling makes it dependable when WS fails.",
          "language": "text",
          "code": "WebSocket (preferred):\n- Client connects with k1 (e.g. /api/ws/auth?k1=...)\n- Server broadcasts \"authenticated\" when callback succeeds\n\nPolling fallback:\n- Client polls /api/auth/status?k1=... every 1–2 seconds\n- Status route should check the session cookie first (works across instances)\n- Then fall back to the pending k1 store if needed\n\nThis dual approach is the “LNURL-with” UX glue: instant when possible, reliable always.\n"
        },
        {
          "id": "vibe-coding-prompt",
          "title": "Portable vibe-coding prompt (LNURL-with)",
          "language": "text",
          "code": "You are an expert TypeScript/Next.js engineer. Help me add Lightning Login (LNURL-auth) to a new or existing project using the “LNURL-with” integration shape: LNURL-auth + short-lived k1 storage + secure session cookie + real-time auth status (WebSocket with polling fallback).\\n\\n## Goal\\nImplement Lightning Login so a user can scan a QR code with a Lightning wallet and authenticate without passwords.\\n\\n## Target app\\n- Framework/runtime: <e.g. Next.js App Router, Express, Cloudflare Workers>\\n- Existing auth/session approach (if any): <cookies, next-auth, jwt, etc>\\n- Hosting constraints: <serverless? multi-instance? websockets allowed?>\\n\\n## Acceptance criteria\\n- LNURL endpoint:\\n  - Generates a cryptographically secure k1 challenge: 32 random bytes encoded as 64 hex characters.\\n  - Stores k1 as pending (single-use, expires after 5 minutes).\\n  - Returns JSON: { k1, lnurl } where lnurl is bech32 encoding of the callback URL.\\n- Callback endpoint:\\n  - Receives query params: tag=login, k1, key (pubkey), sig (signature).\\n  - Rejects missing params, unknown k1, expired k1, or invalid signature.\\n  - Verifies using ECDSA secp256k1 via lnurl.verifyAuthorizationSignature(sig, k1, pubkey) (note the parameter order).\\n  - On success: marks k1 authenticated, creates a secure httpOnly session cookie, invalidates k1 (single-use), and returns { status: \\\"OK\\\" }.\\n- Status signal:\\n  - Frontend can detect auth success quickly.\\n  - Prefer WebSocket; include polling fallback if WS isn’t available.\\n- UI:\\n  - A page/panel with a “Generate login QR” action.\\n  - Shows QR that encodes the LNURL.\\n  - Automatically transitions to logged-in state after auth.\\n\\n## Canonical reference (this demo repo)\\nMirror behavior and security properties from these files (treat them as source-of-truth):\\n- src/app/api/auth/lnurl/route.ts\\n- src/app/api/auth/callback/route.ts\\n- src/app/api/auth/status/route.ts\\n- src/app/api/ws/auth/route.ts\\n- src/lib/lnurl/generateK1.ts\\n- src/lib/lnurl/encodeLNURL.ts\\n- src/lib/lnurl/verifySignature.ts\\n- src/lib/store/pendingLogins.ts\\n- src/lib/session/createSession.ts\\n- src/lib/session/getSession.ts\\n- src/app/demo/LoginPanel.tsx\\n\\n## Working rules\\n- Make the smallest correct change set.\\n- Do not change styling/DOM unless the request is explicitly UI.\\n- Prefer server-side data access where possible.\\n- If the environment can’t edit files, output a patch/diff plus a verification checklist.\\n\\n## Deliverables\\n1) A short implementation plan mapped to files.\\n2) The actual code changes (or a patch).\\n3) A test/verification plan (include at least: signature verification order, k1 expiry, single-use, cookie settings)."
        }
      ],
      "bulletPoints": [
        "Step 1 — Add the primitives: generate k1 (crypto.randomBytes(32)->hex), encode LNURL (lnurl.encode(urlString)), verify signature (lnurl.verifyAuthorizationSignature(sig, k1, pubkey)).",
        "Step 2 — Add a pending k1 store with expiry + single-use semantics (5 minutes; delete after success).",
        "Step 3 — Implement the LNURL route handler (GET): create k1, store it, construct callback URL with tag=login&k1=..., encode to lnurl1..., return { k1, lnurl }.",
        "Step 4 — Implement the callback route handler (GET): validate params, verify k1, verify signature (sig, k1, pubkey), set an httpOnly session cookie, invalidate k1, return {status:\"OK\"}.",
        "Step 5 — Implement the UI + status signal: show QR for lnurl, subscribe to WebSocket for instant success, poll /api/auth/status as fallback, reload/transition to logged-in state."
      ],
      "takeaway": "Treat k1 as cryptographic, short-lived, and single-use — and verify signatures in the correct order (sig, k1, pubkey). The rest is “LNURL-with” glue to make the login feel instant and dependable."
    },
    {
      "id": "architecture",
      "slug": "architecture",
      "kind": "architecture",
      "title": "High-Level Architecture",
      "paragraphs": [
        "LNURL-auth requires a backend that generates k1 challenges, verifies signatures, and manages sessions. The protocol flow involves coordination between your web application, an LNURL endpoint, and the user's Lightning wallet.",
        "The architecture consists of three main components: your web application (frontend and backend), an LNURL-auth endpoint, and the user's Lightning wallet that signs challenges."
      ],
      "bulletPoints": [
        "Client requests LNURL from your server",
        "Server generates a random k1 challenge and stores it temporarily",
        "Wallet scans QR code or receives LNURL",
        "Wallet signs the k1 challenge with a domain-specific key",
        "Server verifies the signature against the public key",
        "Session is created upon successful verification"
      ]
    },
    {
      "id": "protocol-flow",
      "slug": "protocol-flow",
      "kind": "protocol",
      "title": "Protocol Flow",
      "paragraphs": [
        "The LNURL-auth protocol follows a specific sequence of steps. Understanding this flow is crucial for proper implementation.",
        "The flow is a challenge-response pattern: the server generates a random challenge (k1), the wallet proves ownership of a private key by signing it, and the server verifies the signature. This creates cryptographic proof of identity without storing credentials.",
        "Each step has specific requirements: k1 challenges must be cryptographically random and expire after 5 minutes, signatures use ECDSA with secp256k1 (same as Bitcoin), and sessions use httpOnly cookies for security. See the Complete Implementation Walkthrough section for detailed code examples."
      ],
      "codeExamples": [
        {
          "id": "flow-diagram",
          "title": "Simplified Protocol Flow",
          "language": "text",
          "code": "Frontend -> GET /api/auth/lnurl -> Server generates k1 -> Encodes LNURL -> QR Code\nWallet scans QR -> Decodes LNURL -> Derives key -> Signs k1 -> GET /api/auth/callback\nServer verifies k1 & signature -> Creates session cookie -> Returns {status: 'OK'}\nFrontend detects auth -> Reloads -> Shows logged-in state"
        }
      ],
      "bulletPoints": [
        "Frontend requests LNURL from server (no parameters needed)",
        "Server generates 32-byte random k1 challenge and stores it with 5-minute expiration",
        "Server encodes callback URL (with tag=login&k1=...) to bech32 LNURL format",
        "Frontend displays LNURL as QR code",
        "Wallet scans QR, decodes LNURL, derives domain-specific key, signs k1 with ECDSA",
        "Wallet calls callback URL with key (pubkey), sig (signature), and k1",
        "Server verifies k1 exists and isn't expired, then verifies signature",
        "If valid, server creates httpOnly session cookie with pubkey and returns success",
        "Frontend detects authentication via WebSocket or polling and reloads page"
      ]
    },
    {
      "id": "implementation-walkthrough",
      "slug": "implementation-walkthrough",
      "kind": "step-by-step",
      "title": "Complete Implementation Walkthrough",
      "intro": "This comprehensive walkthrough explains how Lightning Login works end-to-end, referencing actual implementation files in this codebase. You'll understand not just what happens, but why each design decision was made and how the cryptography ensures security.",
      "paragraphs": [
        "Lightning Login replaces passwords with cryptographic signatures. Instead of storing credentials, the server generates a random challenge (k1), the wallet proves ownership of a private key by signing it, and the server verifies the signature using public key cryptography. This eliminates credential databases, password resets, and the security risks that come with storing secrets.",
        "The architecture consists of three main components: (1) Frontend React components that display QR codes and manage authentication state, (2) Backend API routes that generate challenges, verify signatures, and manage sessions, and (3) Session management using httpOnly cookies that persist authentication state across page reloads.",
        "The flow follows a challenge-response pattern: Server → Challenge → Wallet → Signature → Server → Session. Each step builds on cryptographic primitives that have been battle-tested in Bitcoin for over a decade.",
        "Why k1 Challenges Matter: The k1 (challenge) is a 32-byte random value generated using cryptographically secure random number generation. It serves multiple security purposes: (1) It's unpredictable - even seeing millions of previous challenges gives no information about the next one, (2) It's time-limited - expires after 5 minutes to prevent stale challenges, (3) It's single-use - deleted immediately after successful authentication to prevent replay attacks, (4) It binds the signature to this specific login attempt - a signature for one k1 cannot be reused for another.",
        "LNURL Encoding Explained: The callback URL is encoded to bech32 format (starting with 'lnurl1...') for several reasons: (1) Shorter than full URLs, making QR codes smaller and easier to scan, (2) Error detection built-in through bech32 checksums, (3) Human-readable format that wallets can easily recognize, (4) Standardized format ensures interoperability across all LNURL-auth compatible wallets. The encoding is reversible - wallets decode it back to the original URL.",
        "Signature Verification Deep Dive: When the wallet signs the k1 challenge, it uses ECDSA (Elliptic Curve Digital Signature Algorithm) with the secp256k1 curve - the same cryptography used in Bitcoin. The signature is a mathematical proof that: (1) The signer controls the private key corresponding to the public key, (2) The signature was created specifically for this k1 challenge (cannot be reused), (3) The k1 challenge hasn't been modified. Verification is deterministic - given the same inputs, it always produces the same result. This is why signature verification is so secure - it's mathematically impossible to forge a signature without the private key.",
        "Session Management Strategy: Sessions use httpOnly cookies containing the user's public key. This design choice has important implications: (1) httpOnly means JavaScript cannot access the cookie, preventing XSS attacks from stealing sessions, (2) The public key is the user identifier - no database lookup needed, (3) Cookies persist across server restarts and work in serverless/multi-instance deployments, (4) Secure flag ensures HTTPS-only transmission in production, (5) SameSite: 'lax' provides CSRF protection. The public key approach is stateless - the server doesn't need to store session data, it just reads the cookie.",
        "Real-Time Updates Architecture: The implementation uses WebSockets for instant authentication feedback, with polling as a fallback. WebSockets provide sub-second latency - when the wallet calls the callback, connected clients are notified immediately. However, WebSockets can fail in some network environments (corporate firewalls, certain proxies), so the frontend also polls /api/auth/status every 2 seconds. The status endpoint checks the session cookie first (which works across server instances), then falls back to the in-memory pending login store. This dual-mechanism ensures authentication is detected reliably.",
        "Production Considerations: The current implementation uses an in-memory Map for storing pending logins. This works fine for single-instance deployments but has limitations in serverless/multi-instance environments where each instance has its own memory. The workaround is that the status endpoint checks the session cookie first, which persists across instances. For production at scale, consider: (1) Redis/Upstash KV for shared k1 storage, (2) Database table for pending logins if you need persistence, (3) Sticky sessions (not ideal for serverless). The session cookie approach already handles multi-instance deployments gracefully.",
        "Security Features Summary: The implementation includes multiple layers of security: (1) Cryptographically random k1 challenges prevent prediction attacks, (2) Time-limited challenges (5 minutes) prevent stale challenge reuse, (3) Single-use challenges prevent replay attacks, (4) ECDSA signature verification provides cryptographic proof of identity, (5) httpOnly cookies prevent XSS session theft, (6) Secure cookies enforce HTTPS in production, (7) SameSite protection mitigates CSRF attacks, (8) Domain-specific key derivation prevents cross-site correlation. Together, these create a robust authentication system without credential storage.",
        "Let's examine each component in detail, starting with how challenges are generated and ending with how sessions are managed. We'll look at actual code from this implementation to see how theory becomes practice."
      ],
      "codeExamples": [
        {
          "id": "generate-k1",
          "title": "Generating k1 Challenge",
          "description": "src/lib/lnurl/generateK1.ts - Simple but cryptographically secure random number generation",
          "language": "typescript",
          "code": "import { randomBytes } from \"crypto\";\n\nexport function generateK1(): string {\n  return randomBytes(32).toString(\"hex\");\n}"
        },
        {
          "id": "lnurl-endpoint",
          "title": "LNURL Endpoint Handler",
          "description": "src/app/api/auth/lnurl/route.ts - Generates challenge, encodes LNURL, and stores pending login",
          "language": "typescript",
          "code": "export async function GET(): Promise<NextResponse> {\n  try {\n    // Generate a new challenge\n    const k1 = generateK1();\n    const callback = `${env.NEXT_PUBLIC_BASE_URL}/api/auth/callback`;\n\n    // Construct callback URL with query parameters\n    const callbackUrl = new URL(callback);\n    callbackUrl.searchParams.set(\"tag\", \"login\");\n    callbackUrl.searchParams.set(\"k1\", k1);\n\n    // Encode to bech32 LNURL format\n    const lnurl = encodeAuthURL(callbackUrl.toString());\n    \n    // Store k1 in memory with expiration\n    createPendingLogin(k1);\n\n    return NextResponse.json({ k1, lnurl });\n  } catch (error) {\n    console.error(\"[LNURL] Error generating challenge:\", error);\n    return NextResponse.json(\n      { status: \"ERROR\", reason: \"Failed to generate login challenge\" },\n      { status: 500 }\n    );\n  }\n}"
        },
        {
          "id": "pending-logins-store",
          "title": "Pending Logins Store",
          "description": "src/lib/store/pendingLogins.ts - In-memory Map storing k1 challenges with expiration",
          "language": "typescript",
          "code": "type PendingLogin = {\n  created: number;\n  pubkey: string | null;\n  status: \"pending\" | \"authenticated\" | \"expired\";\n};\n\nconst pendingLogins = new Map<string, PendingLogin>();\nconst K1_EXPIRY_MS = 5 * 60 * 1000; // 5 minutes\n\nfunction isExpired(created: number): boolean {\n  return Date.now() - created > K1_EXPIRY_MS;\n}\n\nexport function createPendingLogin(k1: string): void {\n  pendingLogins.set(k1, {\n    created: Date.now(),\n    pubkey: null,\n    status: \"pending\",\n  });\n}\n\nexport function getPendingLogin(k1: string): PendingLogin | undefined {\n  const login = pendingLogins.get(k1);\n  if (!login) return undefined;\n  \n  if (isExpired(login.created)) {\n    login.status = \"expired\";\n    return login;\n  }\n  \n  return login;\n}"
        },
        {
          "id": "callback-handler",
          "title": "Callback Handler - Signature Verification",
          "description": "src/app/api/auth/callback/route.ts - Verifies k1, validates signature, creates session",
          "language": "typescript",
          "code": "export async function GET(request: Request): Promise<NextResponse> {\n  const { searchParams } = new URL(request.url);\n  const k1 = searchParams.get(\"k1\");\n  const key = searchParams.get(\"key\"); // public key\n  const sig = searchParams.get(\"sig\"); // signature\n\n  // Validate parameters\n  if (!k1 || !key || !sig) {\n    return NextResponse.json(\n      { status: \"ERROR\", reason: \"Missing parameters\" },\n      { status: 400 }\n    );\n  }\n\n  // Verify k1 exists and not expired\n  const pendingLogin = getPendingLogin(k1);\n  if (!pendingLogin || pendingLogin.status === \"expired\") {\n    return NextResponse.json(\n      { status: \"ERROR\", reason: \"Invalid or expired k1\" },\n      { status: 403 }\n    );\n  }\n\n  // Verify cryptographic signature\n  const isValid = verifyAuthSignature(key, sig, k1);\n  if (!isValid) {\n    return NextResponse.json(\n      { status: \"ERROR\", reason: \"Invalid signature\" },\n      { status: 403 }\n    );\n  }\n\n  // Create session and broadcast success\n  completeLogin(k1, key);\n  await createSession(key);\n  broadcastAuthSuccess(k1, key);\n  removePendingLogin(k1);\n\n  return NextResponse.json({ status: \"OK\" });\n}"
        },
        {
          "id": "create-session",
          "title": "Session Creation",
          "description": "src/lib/session/createSession.ts - Sets httpOnly cookie with public key",
          "language": "typescript",
          "code": "import { cookies } from \"next/headers\";\n\nexport async function createSession(pubkey: string): Promise<void> {\n  (await cookies()).set(\"ll-session\", pubkey, {\n    httpOnly: true,    // JavaScript cannot access (XSS protection)\n    secure: process.env.NODE_ENV === \"production\", // HTTPS only\n    sameSite: \"lax\",  // CSRF protection\n    path: \"/\",        // Available site-wide\n  });\n}"
        },
        {
          "id": "frontend-login",
          "title": "Frontend Login Flow",
          "description": "src/app/demo/LoginPanel.tsx - Generates QR code and connects WebSocket",
          "language": "typescript",
          "code": "async function start() {\n  try {\n    setStep(\"generating\");\n    \n    // Request LNURL from server\n    const res = await fetch(\"/api/auth/lnurl\");\n    const data = await res.json();\n    \n    // Generate QR code from LNURL\n    const qrData = await QRCode.toDataURL(data.lnurl);\n    setQr(qrData);\n    setStep(\"waiting\");\n    \n    // Connect WebSocket for real-time updates\n    const protocol = window.location.protocol === \"https:\" ? \"wss:\" : \"ws:\";\n    const wsUrl = `${protocol}//${window.location.host}/api/ws/auth?k1=${data.k1}`;\n    const ws = new WebSocket(wsUrl);\n    \n    ws.onmessage = (event) => {\n      const message = JSON.parse(event.data);\n      if (message.type === \"authenticated\") {\n        window.location.reload(); // Show logged-in state\n      }\n    };\n  } catch (err) {\n    setError(err instanceof Error ? err.message : \"Failed to start login\");\n  }\n}"
        },
        {
          "id": "verify-signature",
          "title": "Signature Verification",
          "description": "src/lib/lnurl/verifySignature.ts - ECDSA signature verification using lnurl package",
          "language": "typescript",
          "code": "import lnurl from \"lnurl\";\n\nexport function verifyAuthSignature(\n  pubkey: string,\n  sig: string,\n  k1: string\n): boolean {\n  // lnurl.verifyAuthorizationSignature expects: (sig, k1, pubkey)\n  // Uses ECDSA with secp256k1 curve (same as Bitcoin)\n  return lnurl.verifyAuthorizationSignature(sig, k1, pubkey);\n}"
        }
      ],
      "bulletPoints": [
        "Step 1: User Initiates Login - In src/app/demo/LoginPanel.tsx, when a user clicks 'Generate Login QR Code', the start() function calls fetch('/api/auth/lnurl'). This is a simple GET request with no parameters - the server generates everything needed. The frontend sets state to 'generating' to show loading feedback. This separation of concerns means the frontend doesn't need to know anything about cryptography or challenge generation.",
        "Step 2: Server Generates k1 Challenge - The GET handler in src/app/api/auth/lnurl/route.ts calls generateK1() from src/lib/lnurl/generateK1.ts. This function uses Node.js crypto.randomBytes(32) to generate 32 random bytes, then converts them to a hex string (64 characters). Example: 'f0373682e8b889c8d8ae195374d14257f7e32ee72815439631b4b70d19762014'. This k1 is cryptographically random and unpredictable - even if an attacker sees millions of previous k1 values, they cannot predict the next one. The k1 is stored in an in-memory Map via createPendingLogin() in src/lib/store/pendingLogins.ts with metadata: {created: timestamp, pubkey: null, status: 'pending'}. A 5-minute expiration timer is set to prevent stale challenges from being reused.",
        "Step 3: Construct Callback URL - The server builds the callback URL by creating a new URL object pointing to /api/auth/callback, then adds query parameters: tag=login (tells wallets this is LNURL-auth) and k1=<the challenge>. The full URL looks like: 'https://yoursite.com/api/auth/callback?tag=login&k1=f0373682...'. This URL structure is standardized by the LNURL-auth specification (LUD-04) so all compatible wallets understand it.",
        "Step 4: Encode to LNURL (Bech32) - The callback URL string is passed to encodeAuthURL() in src/lib/lnurl/encodeLNURL.ts, which calls lnurl.encode() from the 'lnurl' npm package. This converts the URL to bech32 format, creating a string like 'lnurl1dp68gurn8ghj7mrfva58gmnfdenj6mr0va5kutnrdakj7ctsdyhkzat5dqhk...'. Bech32 encoding is used because it's QR-code friendly (shorter than full URLs), includes error detection, and is human-readable. The 'lnurl1' prefix tells wallets this is an LNURL that needs decoding. The server returns {k1, lnurl} as JSON to the frontend.",
        "Step 5: Frontend Generates QR Code - LoginPanel.tsx receives the response and extracts the lnurl string. It calls QRCode.toDataURL(lnurl) from the 'qrcode' library to generate a data URL containing the QR code image. This QR code encodes the bech32 LNURL string. The component sets state to 'waiting' and displays the QR code. Simultaneously, it establishes a WebSocket connection to ws://yoursite.com/api/ws/auth?k1=<k1> for real-time authentication updates. If WebSocket fails (common in some network environments), it falls back to polling /api/auth/status every 2 seconds.",
        "Step 6: Wallet Scans and Processes - When the user scans the QR code with their Lightning wallet (Breez, Alby, Wallet of Satoshi, etc.), the wallet: (a) Decodes the bech32 string back to the original URL, (b) Recognizes tag=login as an LNURL-auth request, (c) Extracts the k1 challenge, (d) Derives a domain-specific private key using BIP32-like derivation (each domain gets a unique key to prevent cross-site correlation), (e) Signs the k1 challenge with this private key using ECDSA (Elliptic Curve Digital Signature Algorithm), (f) Constructs the callback URL with query parameters: k1=<challenge>, key=<public key>, sig=<signature>, (g) Makes a GET request to this callback URL. The signature proves the wallet controls the private key without revealing it.",
        "Step 7: Server Receives Callback - The callback handler in src/app/api/auth/callback/route.ts receives the GET request. It extracts three query parameters: k1 (the challenge), key (the public key, hex-encoded), and sig (the signature, hex-encoded). The handler first validates all three parameters exist - if any are missing, it returns {status: 'ERROR', reason: 'Missing parameters'} with HTTP 400. This validation prevents malformed requests from proceeding.",
        "Step 8: Verify k1 Challenge - The handler calls getPendingLogin(k1) from src/lib/store/pendingLogins.ts to look up the challenge. This function checks: (a) Does the k1 exist in the Map? If not, return undefined (challenge never existed or was already used). (b) Has the challenge expired? The store checks if Date.now() - created > 5 minutes. If expired, it marks status as 'expired' and returns it. (c) Is the status still 'pending'? If already authenticated, this prevents replay attacks. If the k1 is invalid or expired, the handler broadcasts an error via WebSocket and returns {status: 'ERROR', reason: 'Invalid or expired k1'} with HTTP 403.",
        "Step 9: Verify Cryptographic Signature - If the k1 is valid, the handler calls verifyAuthSignature(key, sig, k1) from src/lib/lnurl/verifySignature.ts. This function calls lnurl.verifyAuthorizationSignature(sig, k1, pubkey) from the 'lnurl' package. Internally, this performs ECDSA signature verification: it takes the signature, the original message (k1), and the public key, and mathematically verifies that the signature could only have been created by someone who controls the private key corresponding to that public key. The verification uses the same cryptography as Bitcoin transactions - if it's secure enough for billions of dollars, it's secure enough for authentication. If verification fails, the handler returns {status: 'ERROR', reason: 'Invalid signature'} with HTTP 403.",
        "Step 10: Create Session Cookie - Upon successful signature verification, the handler calls completeLogin(k1, key) to mark the challenge as authenticated in the store, then createSession(key) from src/lib/session/createSession.ts. This function uses Next.js cookies() API to set an httpOnly cookie named 'll-session' with the public key as the value. The cookie is configured with: httpOnly: true (JavaScript cannot access it, preventing XSS attacks), secure: true in production (HTTPS only), sameSite: 'lax' (CSRF protection), path: '/' (available site-wide). The public key becomes the user's identifier - no username, email, or password needed.",
        "Step 11: Broadcast Success - After creating the session, the handler calls broadcastAuthSuccess(k1, key) from src/lib/websocket/authStatusServer.ts. This function finds all WebSocket clients subscribed to this k1 and sends them a JSON message: {type: 'authenticated', k1, pubkey}. The frontend receives this message and knows authentication succeeded. The handler then calls removePendingLogin(k1) to delete the challenge from memory (single-use enforcement) and returns {status: 'OK'} as required by the LNURL-auth specification.",
        "Step 12: Frontend Detects Authentication - The frontend has two mechanisms to detect authentication: (a) WebSocket: If connected, it receives the 'authenticated' message immediately. (b) Polling fallback: If WebSocket isn't available, LoginPanel.tsx polls /api/auth/status every 2 seconds. The status endpoint in src/app/api/auth/status/route.ts first checks the session cookie (which persists across server instances), then falls back to checking the pending login store. This dual-check ensures authentication is detected even in serverless/multi-instance deployments where the in-memory store might not persist. When authentication is detected, the frontend sets state to 'authenticated' and reloads the page after 500ms.",
        "Step 13: Page Reload and Session Check - After reload, the demo page (src/app/demo/page.tsx) is a server component that calls getSession() from src/lib/session/getSession.ts. This function reads the 'll-session' cookie using Next.js cookies() API. If the cookie exists, it returns the public key (the user identifier). If not, it returns null. The page conditionally renders: if session exists, show LoggedIn component; otherwise, show DemoContent (which includes LoginPanel).",
        "Step 14: Display Authenticated State - The LoggedIn component (src/app/demo/LoggedIn.tsx) receives the pubkey as a prop and displays it to the user. It also provides a logout button that calls POST /api/auth/logout, which deletes the session cookie. The public key serves as proof of identity - it's unique, derived from the user's wallet, and cannot be forged."
      ],
      "takeaway": "Lightning Login is stateless except for the session cookie. The k1 challenge is single-use (deleted after authentication) and time-limited (5-minute expiration), preventing replay attacks. Authentication relies on cryptographic proof (ECDSA signature verification) rather than stored credentials - the same cryptography securing Bitcoin transactions. The public key serves as the user identifier, eliminating usernames, emails, password databases, and credential breach risks. The entire system is designed to be simple, secure, and sovereign - users control their identity through their wallet, not through a centralized provider."
    },
    {
      "id": "implementing-simple",
      "slug": "implementing-simple",
      "kind": "code-example",
      "title": "Implementing LNURL-auth (Simple Server)",
      "paragraphs": [
        "Here's a basic implementation of LNURL-auth for a simple Node.js or Next.js server. This example shows the core concepts without additional abstractions."
      ],
      "codeExamples": [
        {
          "id": "simple-server",
          "title": "Simple Node/Next.js Endpoint",
          "description": "Basic LNURL-auth endpoint implementation",
          "language": "typescript",
          "code": "export async function GET() {\n  // Generate random k1 challenge\n  const k1 = crypto.randomBytes(32).toString('hex');\n\n  // Store k1 temporarily (in-memory or Redis)\n  // Store with expiration (e.g., 5 minutes)\n\n  // Return LNURL response\n  return Response.json({\n    tag: 'login',\n    k1: k1,\n    callback: 'https://yoursite.com/api/lnurl-auth/callback',\n    host: 'yoursite.com',\n  });\n}"
        }
      ]
    },
    {
      "id": "implementing-nextauth",
      "slug": "implementing-nextauth",
      "kind": "code-example",
      "title": "Integrating with NextAuth",
      "paragraphs": [
        "NextAuth can wrap LNURL-auth for session management. This allows you to leverage NextAuth's built-in session handling while using Lightning Login for authentication.",
        "You'll need to create a custom NextAuth provider that implements the LNURL-auth flow."
      ],
      "codeExamples": [
        {
          "id": "nextauth-provider",
          "title": "NextAuth LNURL Provider",
          "description": "Custom provider implementation",
          "language": "typescript",
          "code": "// Placeholder for NextAuth integration\n// This will be expanded in a future update"
        }
      ]
    },
    {
      "id": "libraries",
      "slug": "libraries",
      "kind": "library",
      "title": "Library Ecosystem",
      "paragraphs": [
        "Several libraries exist to help you implement LNURL-auth. Here are the main options available in the JavaScript/TypeScript ecosystem."
      ],
      "bulletPoints": [
        "lnurl (npm): Low-level primitives for LNURL encoding, decoding, and signature verification. Used in this implementation for bech32 encoding and ECDSA signature verification.",
        "passport-lnurl-auth: Express/Passport strategy for LNURL-auth integration",
        "lightning-backends: Additional Lightning Network utilities (note: not required for LNURL-auth, only signature verification is needed)"
      ]
    },
    {
      "id": "comparison",
      "slug": "comparison",
      "kind": "comparison",
      "title": "Methods Comparison",
      "paragraphs": [
        "Different implementation approaches have different trade-offs. Choose the method that best fits your application's needs."
      ],
      "comparisonTable": {
        "columns": ["Method", "Effort", "Flexibility", "Use Case"],
        "rows": [
          ["Simple Endpoint", "Low", "Medium", "Custom servers"],
          ["NextAuth Provider", "Medium", "High", "Web apps needing sessions"],
          ["Passport Strategy", "Medium", "High", "Express/Node APIs"]
        ]
      }
    },
    {
      "id": "faq",
      "slug": "faq",
      "kind": "faq",
      "title": "Developer FAQ",
      "paragraphs": [
        "Q: Do I need a Lightning node to implement LNURL-auth?",
        "A: No, you don't need your own Lightning node. The protocol only requires that users have a Lightning wallet that can sign challenges. Your server just needs to verify signatures using ECDSA (secp256k1). No Lightning payments or channels are involved — it's pure cryptographic signature verification.",
        "",
        "Q: How do I handle key derivation for domain-specific keys?",
        "A: LNURL-auth uses BIP32-like hierarchical deterministic derivation. Each domain gets its own linking key (public key) derived from the user's wallet seed. The wallet handles this derivation automatically — your server only receives the public key and verifies signatures. You don't need to implement key derivation on the server side.",
        "",
        "Q: What happens if a user loses their wallet?",
        "A: If a user loses access to their wallet and doesn't have a backup, they lose that identity (similar to losing a hardware security key). Consider implementing account recovery mechanisms (linking additional keys, email fallback, etc.) if needed for your use case. The public key serves as the user identifier, so losing the private key means losing access to that account.",
        "",
        "Q: Can I use LNURL-auth with existing user accounts?",
        "A: Yes, you can link Lightning Login to existing accounts or use it as the primary authentication method. You can map the public key (pubkey) to existing user records in your database, or use the pubkey as the primary identifier. The choice depends on your application's requirements.",
        "",
        "Q: What's the difference between k1 and the public key?",
        "A: The k1 is a temporary 32-byte random challenge generated by your server for each login attempt. It expires after 5 minutes and is single-use. The public key (pubkey) is the user's permanent identifier derived from their wallet seed. The wallet signs the k1 challenge with its private key, proving ownership without revealing the private key.",
        "",
        "Q: How do I handle multi-instance/serverless deployments?",
        "A: The current implementation uses an in-memory Map for k1 storage, which doesn't persist across instances. For production, use Redis/Upstash KV for shared k1 storage, or rely on the session cookie (which persists across instances) and check it first in your status endpoint. The session cookie approach already handles multi-instance deployments gracefully."
      ]
    }
  ]
}
